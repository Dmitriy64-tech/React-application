Роутинг в Реакт:
1) Сделал через Route, все работает, но страница перезагружаеться, а она не должна.
2) Заменяем обычные ссылки в навбаре на NavLink и страница не перезагружаеться(href меняем на to)
3) exact для Route делает отображения странички, только если адрес 
абсолютно точный, без вложений
4)Что бы передать пропсы через Роут нужно использовать такую констукцию. Например:
<Route exact path="/" render={() => <Profile Данные={Данные}/>} />

Выносил данные из компонент в index.js (пока не правильно, но не так неправильно, как хранить данные в компонентах):
-Прокидываем данные через все верхние компоненты, передавая их через пропсы на кажный слой ниже! ->>>>> Вынес данные в state.js

Чтобы обратиться к какому-то элементу на странице мы не должные использовать обращение к непосредственно DOM-элементу, а к виртуал ДОМУ. 
Например: 

////////////////////////////////////////////////////////////////////////////////
let newPostElement = React.createRef(); //создаем ссылку на объект
<textarea ref={newPostElement}></textarea>//объекту даем это имя ссылки
let text = newPostElement.current.value//получаем значенние элемента


///////////////////////////////Добавление поста на стену//////////////////////////////////////////
При добавлении какой-то информации в state мы не видим ее отбражение на странице. Это связано с тем, что страница
 рендериться один раз, и изменения в state  просто не прокидываються. 
*fixed*

////////////////////////////////Рефакторинг///////////////////////////////////////////////
Удаляем файл рендер. Весь код из него переносим в индекс.жс. Получаеться, что у нас в индексе
инициализация и вызов функции rerenderEntireTree. Чтобы небыло циклической зависимости между 
state.js и index.js. Для этого в state мы создаем функцию subscribe и импортируем ее в индекс.
subscribe принимает на вход observer. Вызываем ее в идекс и передаем туда функцию rerenderEntireTree
, потомучто она нужна нам в state.js. Так же в state.js мы уже имели функцию заглушку rerenderEntireTree.
А в subscribе мы ее переопределили на функцию observer(rerenderEntireTree).
///////////////////////////Рефакторинг/////////////////////////////////////////////////////
В store  все функции связаные изменением состояния нашего state мы помещаем в отдельный метод dispatch.
Он принимает объект, который принимает объект со свойством type: 'some-type'. В зависимости от этого типа
будет вызываться соотвествующий метод изменения state'ta.
/////////////////////////////Редьюсеры//////////////////////////////////////////////////////
Всю логику из метода dispatch мы переносим в отдельные файлы-редьюсеры. Каждый из которых принимет нужную часть
стейта и как-то ее меняет в зависимости от переданого экшена. В методе dispatch остаюсться вызовы редьюсеров и 
перересовка всего дерава(вызов субскрайбера).

///////////////////////////////Подключил Redux///////////////////////////////////////////
//////////////////////////////Контейнерные компоненты//////////////////////////////////////
Обернул компоненты MyPosts and Dialogs в контейнерные компоненты. Эти компоненты в пропсах получают весь store.
В себе они его расскукоживают и компоненты MyPosts and Dialogs в себя получают толко данные и коллбеки.
Контейнерные компоненты их просто отрисовывают.
//////////////////////////////////Контекст/////////////////////////////////////////////////////////
Контекст используеться довольно редко, но он нужен чтобы передавать какие-то данные в глубоко вложенные компоненты
не череза пропсы по всему дереву, а сразу. Мы запихиваем данные в контекст в начале дерева, а потом их вытвскиваем
из него там, где нам это нужно.
///////////////////////////////////Копирование объектов///////////////////////////////////////////////////////////
Если мы имеем var a = {......} и хотим его клонировать то нужно прописать var b = {...a} - это неглубокая копия объекта.
(Если в объекте а есть вложеные объекты, то они не клонируються, а остануться ссылки на те же области памяти с объектами 
внутри объкт а)
/////////////////////////////////////Рефакторинг///////////////////////////////////////////////////////////////
Из индекса убираем подписку на полную перерисовку Virual-DOM. Она будет происходить в тех местах, где мы прописывали connect
автоматически, и только этот кусок дерева, а не все полностью. 
До этого момента перерисовка не протзводилась, потому что не смотря на то, что state у меня менялся добавлением поста, connect
перерерисовывает объкт в том случае, если он поменялся не внутри, а если он получил ссылку на другой объект. Для этого я создал копию 
state и редьюсер возвращает не 
//////////////////////////////////Презентационная и Контейнерная компоненты///////////////////////////////////////////////////////////
Презентационная компонента должна получать пропсы и вазвращать jsx разметку. Она не должна нести в себе логики работы, аякс запросов. 
Она должна вести себя предсказуемо. При передачи одних и тех же данных мы должны получать на выход одну и туже разметку. 
Контейнерная компонента должна оборачивать презентационную и непосредственно работать со store с помощью функций mapStateToProps and
mapDispatchToProps. 
В моем случае компонета Users не презентационная, потому что она отправляет аякс запросы на сервер. И айякс локику перекидываю в 
контейнерную компоненту
////////////////////////////////////mapStateToProps изменения//////////////////////////////////////////////////////////////////////
Мой ХОК connect принимал в себя функцию mapStateToProps. Эта функция возвращала объект с колбеками в которых был прописан диспач 
моих экшенКриейторов. По факту, это не нужное занятие, потому что connect сам знает что и как нужно диспатчить. По этому вместо 
mapStateToProps в него можно передать всего лишь объкт с экшенКриейторами. Сonnect сам все задиспатчит и все будет работать.
///////////////////////////////////WithRouter///////////////////////////////////////////////////////////////////////////////////////
Это ХОК, который позволяет ЮАю анализировать УРЛ и позволяет мне выбырать профиль нужного пользователя по его ИД. Для этого в теге 
<Route path='/profile/:userID?' я установил параметр userID со знаком вопроса(не обязательный). И перед тем как ProfileContainer 
передать в connect я оборачиваю его в ХОК WithRouter.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
AJAX запрос может иметь параметр настройки {withCredentials: true}. Он говорит о том, что используються куки-файли вместе с запросом.
И передаються данные про залогиненого пользователя. (У гет запроса это второй параметр, а у пост и делит - третий).
Добавил пост запрос на подписку на пользвателя и делит запрос на отписку от пользователя. Вместе с этими запросами нужно указывать 
API-KEY, который можно найти в апишке.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Создал файл API и вынес в него метод GetUsers, который отправляет аякс запрос за пользователями. И вызываю этот метод в юзер Контейнере.
Так же всеми остальными запросами. В этих методах я воспользовался промисами, но пока я не понимаю что это)
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Создал переменную аxiosInstance = axios.create() в которую передал объект с параметрами, которые нужны при отравке запроса на сервак. И при вызове 
теперь идет обращение не аксиосу, а к аxiosInstance. Даже базовый общий для всех запросов УРЛ тоже передал в виде параметров.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Сделал дизейбл кнопки подписки при нажатии. Для этого добавил в юзер стейт параметр isFollowingInProgress: [] в виде массива. Идея в том, что 
свойство disabled={props.isFollowingInProgress.some(id => id === u.id)} работает в том случае, если в массиве есть айди нужного юзера. Создал АС 
который принимает айди юзера, и булевую переменную, говорящюю о том, идет ли процес подписки/отписки на пользователя. И в это время нужный айди
попадает в массив, и кнопка становиться неактивной, пока идет запрос. В конце запроса в коллбек передаеться значение фолс и айди юсера, который 
пропадает из массива, и кнопка не дизейблиться.
//////////////////////////////////////////////////////////Сделал thunk's////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////Redirect//////////////////////////////////////////////////////////////////////////////
Если пользователь за залогинен, то его не пускает на страницу профиль и сообщения, а редиректит на страницу логина. Сделано с помощью компоненты
<Redirect>.
Для єтого был создан ХОК withAuthRedirect, который дополнительно в себе конектит пропсы для редиректа, и их не надо передавать в основном конекте.
///////////////////////////////////////////////////////Compose////////////////////////////////////////////////////////////////////////////////////////
Фунция Compose позволяет объеденить поледовательность из ХОКов в один объект для более удобного их вызова и работы с ними.
/////////////////////////////////////////////////////Redux-form/////////////////////////////////////////////////////////////////////////////////////
Заменил все поля ввода на формы, чтобы боло удобнее работать с ними и валидировать. В FormControls я создал кастомные компоненты, и передаю их филдам,
чтобы можно было менять их адеватно в зависимости от валидации. Для того, чтобы корректно разбить пропсы использовал такой синтаксис. Вмест просто
props пишу {input, meta, ...props} это значит, что пропсы теперь будут содержать все кроме инпута и меты. 
////////////////////////////////////////////////Инициализация приложения//////////////////////////////////////////////////////////////////////////////////
Создал редьюсер в котором определяю прошла ли полностью инициализация приложения. Очень интересный момент: Делаю так, чтобы санка getAuthUserData() все возврвщвла
свой запрос а не просто выполяняла. В нвом редьюсере создаю санку, которая диспатчит санку getAuthUserData. Она возвращает промис. Потом через than диспатчу экшен,
 который меняет состояние инициализации на истинное. Оно выполниться, только тогда, когда  getAuthUserData отработает. И рисую АПП только если все готово.
 Теперь нет проблем с тем, что страница рисуеться раньше чем происходит логинизация и меня не кидает по страницам куда попало.
 ///////////////////////////////////////Селекторы/////////////////////////////////////////////////////////////////////////////////////////////////////////////
 Каждый раз как мне нужно обраться к стейту за данными я это делаю в mapStateToProps и там обращаюсь к ним и пишу полный путь. Но если какое-то поле в стейте 
 поменяет свое название, то мне придеться во всех местах менять это название. Что б этого избежать я делаю селекторы. Например GetUsers(state). Он выковыривает 
 из стейта то, что мне надо, и эту функцию я потом использую во всех местах где мне это нужно. Без дублирования кода.
 функция createSelector создает реселектор, она принимает в качестве зависимостей простые селекты из стейта (селекты без сложных вычислений), при первом вызове реселекта 
 значения зависимостей кешируются внутри реселекта, а при следующих вызовах дергаются простые селекторы зависимости и их  значения сравниваются с кешироваными!
Если изменений по сравнению с кешем нет, то сразу возвращается кеншированный результат без запуска дорогого селектора,
если же что-то из зависимостей изменилось в стейте по сравнению с кешем то тогда уже вызывается 
селектор с дорогими вычислениями!
////////////////////////////////////////////////////Хуки/////////////////////////////////////////////////////////////////
Хук useState позволяет легко добавлять "локальный стейт" в функциональную компоненту и его редактировать.
Хук useEfect довольно сложный, про него в закладках целая статья на миллион страниц, но он позволяет вызывать какую-то функцию при изменении какого-то элемента, 
или после отрисовки всей страницы.
Здесь сложно написать все это. Дальше буду его изучать! Хуки запещено использовать в условиях и циклах!!!
/////////////////////////////////////////////////shouldComponentUpdate/////////////////////////////////////////////////////////////////////////////////////////
Метод жизненного цикла shouldComponentUpdate позволет проверить стоит ли лбновить компонету. В нем можно проверить поменялись ли стейт или пропсы и в случае если они
не поменялись, то компонента просто не обновиться. Это полностью реализовано в PureComponent, по-єтому можно наследовать классовую компоненту от него и получть эту
проверку автоматически.
Если не использовать классовую компоненту, то использовать ХОК React.memo и обернуть в него всю компоненту. Работает аналогично!
////////////////////////////////////////////////////Чистая функция/////////////////////////////////////////////////////////////////////////////////////////////////////
Критерии:
-Имьютабельность - не изменяет пропсы, которые пришли в нее 
- Фунция обязатено возвращает данные (копию объекта)
- Нет сайд-эфектов
- Идемпотентность - При одинаковых пропсас всегда возращеться одиноковый ответ.
////////////////////////////////////////////////React.lazy React.Suspense///////////////////////////////////////////////////////////////////////////////////////////
В случае обычного импорта, импортированые компоненты сразу подшружаються реактом. Это может замедлить первую прогрузку приложения. Импортировать можно с помощью React.lazy
в таком случае компонента будет загружаться только при ее непосредственной отрисовке. Вызов компоненты нужно обернуть в тег React.Suspense.